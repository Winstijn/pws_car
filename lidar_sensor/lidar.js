//
//  PWS AI
//  lidar.js
//
//  Created by Winstijn Smit
//  Copyright Â© 2019 Kaziaat B.V. All rights reserved.
//

const { spawn } = require('child_process');

class LidarSensor {

    constructor(settings={}){
        this.log("Initialising Lidar Sensor v1.0!");
        this.debug = settings.debug || false 

        // Starting process on system to communicate with Lidar!
        this.lidarProcess = this.spawnProcess();
        this.lidarProcess.stdout.on('data', this.parseData.bind(this))
        this.lidarProcess.on('close', this.processClosed.bind(this))

        // Define Sensors with the angle. (Eenheidcirkel)
        // Motor on the left on the center is the point (1, 0). 
        // All angels are defined that way.
        this.sensors = {
            front: Math.PI,
            frontLeft: Math.PI * 5 / 4,
            frontRight: Math.PI * 3 / 4,
            left: Math.PI * 1.5,
            right: Math.PI * 0.5,
        }

        // Gets generated by this library!
        this.latestSensorData = {
            // Example!
            front: {distance: 12.0, angle: 0.23}
        }

        // Function that gets called when the Lidar completed a scan!
        this.scanCallback = settings.onScan || (() => {})
    }    

    // Process containts YDLidar library code C++.
    spawnProcess(){
        return spawn('/opt/ydlidar_node/build/ydlidar_node');        
    }

    processClosed(){
        this.log("Lidar Sensor has been disconected.")
    }

    parseData(data){
        const dataString = data.toString()
        if ( dataString.includes('start_scan') || dataString.includes('data_point') || dataString.includes('end_scan') ) {
            var scanItems = dataString.split('\n')
            for (let i = 0; i < scanItems.length; i++) {
                this.handleScanItem(scanItems[i]);
            }
            return
        }
        if (this.debug) console.log("=== STDOUT ===");
        if (this.debug) console.log(dataString);
    }

    handleScanItem(scanItem){
        if (scanItem.includes('data_point')){
            this.findClosestSensor(scanItem)
            return
        }

       if (scanItem.includes('start_scan')) {
            if (this.debug) this.log("Parsing sensor data from Lidar!")
            this.latestSensorData = {}
            return
       }
       
       if (scanItem.includes('end_scan')) {
            if (this.debug) this.log(this.latestSensorData)
            this.scanCallback(this.latestSensorData);
            return
       }
    }

    findClosestSensor(dataPointString){
        // Converting data point string to something we can understand!!
        // "data_point:0.00:0.33761" ==> [4.2, 0.23] - [distance, angle]
        var dataPoint = dataPointString.split(":").slice(1).map( s => Number(s) )

        // Angle of dataPoint!
        // Redefining if angle is negative -> mapping to 0 to 2pi
        var angle = (dataPoint[1] < 0) ? (Math.PI * 2 + dataPoint[1]) : dataPoint[1]

        // Looping through all the sensors!
        var sensorNames = Object.keys(this.sensors) 
        for (let i = 0; i < sensorNames.length; i++) {
            const sensorName = sensorNames[i]
  
            // If it is not closer or not set it to this data point!
            if (this.latestSensorData[sensorName] && !this.dataPointIsCloser( this.sensors[sensorName], this.latestSensorData[sensorName].angle, angle)) continue;

            // Set the sensor dataPoint as this current dataPoint!
            this.latestSensorData[sensorName] = { distance: dataPoint[0], angle: angle }
        }
    }

    // Checking if this dataPointAngel 
    dataPointIsCloser(sensorAngle, closestAngle, dataPointAngle){     
        return Math.abs(sensorAngle - dataPointAngle) < Math.abs(sensorAngle - closestAngle)
    }

    log(...args){
        console.log("[LidarSensor]", ...args)
    }



}

module.exports = LidarSensor



